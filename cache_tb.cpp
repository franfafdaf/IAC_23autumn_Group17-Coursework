#include "verilated.h"
#include "verilated_vcd_c.h"
#include "Vcache.h" // Make sure this includes the correct class name generated by Verilator

#include <iostream>

#define MAX_SIM_CYC 100

int main(int argc, char **argv) {
    Verilated::commandArgs(argc, argv);
    Vcache* cache = new Vcache;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    cache->trace(tfp, 99);
    tfp->open("cache.vcd");

    cache->clk = 0;
    cache->we = 0;
    cache->address_in = 0;
    cache->data_in = 0;

    for (int cycle = 0; cycle < MAX_SIM_CYC; cycle++) {
        // Tick the clock for the testbench
        cache->clk = !cache->clk;
        cache->eval();
        tfp->dump(2 * cycle);
        
        // Tock the clock for the testbench
        cache->clk = !cache->clk;
        cache->eval();
        tfp->dump(2 * cycle + 1);

        // Write then read same address (expect cache hit)
        if (cycle == 10) {
            cache->we = 1; 
            cache->address_in = 0x1000;
            cache->data_in = 0xABCD;
        }

        if (cycle == 20) {
            // Attempt to read from the same address to check for a hit
            cache->address_in = 0x1000;  
        }

        // Write different address, then read first address
        if (cycle == 30) {
            cache->we = 1;  
            cache->address_in = 0x1005;  
            cache->data_in = 0x1234;
        }
        
        //check if the first address is still correct
        if (cycle == 40) {
            cache->address_in = 0x1000;  
        }

        // Test Scenario 3: Repeated writes to the same address
        if (cycle >= 50 && cycle < 55) {
            cache->we = 1;  // Enable write
            cache->address_in = 0x1000;
            cache->data_in = cycle;  // Writing different data each cycle
        }

        if (cycle == 55) {
            cache->we = 0;  // Disable write after repeated writes
        }

        // Test Scenario 4: Read from an unwritten address (expect cache miss)
        if (cycle == 60) {
            cache->address_in = 0x1020;  // Unwritten address
        }
        
        // Overlapping Write-Read Test
        if (cycle == 70) {
            cache->we = 1; // Start write
            cache->address_in = 0x1100;
            cache->data_in = 0x5555;
        }
        if (cycle == 71) {
            cache->we = 0; // Next cycle, start read without waiting for write to complete
            cache->address_in = 0x1100; // Should read the data that was just written
        }

        // Pipeline Stall Test
        if (cycle == 80) {
            cache->we = 1; // Start write
            cache->address_in = 0x1200;
            cache->data_in = 0x6666;
            // Simulate stall by not changing we to 0 in the next cycle
        }
        if (cycle == 82) {
            cache->we = 0; // Continue after stall
            cache->address_in = 0x1200; // Read the address after stall
        }

        // Read from Evicted Address
        if (cycle == 84 || cycle == 85 || cycle == 86 || cycle == 87) {
            cache->we = 1;  // Enable write
            cache->address_in = 0x3000 + (cycle - 80) * 0x100; // Write to different addresses
            cache->data_in = cycle;
        }
        if (cycle == 88) {
            cache->we = 0;  // Disable write
            cache->address_in = 0x3000;  // Attempt to read the first address written, expecting a miss
        }

        // Checks and print statements
        if (cycle == 21 || cycle == 41 || cycle == 56 || cycle == 61) {
            if (cache->cache_hit) {
                std::cout << "Cycle " << cycle << ": Cache hit. Data: " << std::hex << cache->data_out << std::endl;
                if ((cycle == 20 && cache->data_out != 0xABCD) ||
                    (cycle == 55 && cache->data_out != 54)) {  
                    std::cout << "ERROR: Incorrect data!" << std::endl;
                }
            } else {
                std::cout << "Cycle " << cycle << ": Correct Cache miss for unwritten address." << std::endl;
            }
        }

        // Overlapping Write-Read Test
        if (cycle == 72) {
            if (cache->cache_hit) {
                std::cout << "Cycle " << cycle << ": Cache hit. Data: " << std::hex << cache->data_out << std::endl;
                if (cache->data_out != 0x5555) {
                    std::cout << "ERROR: Incorrect data for Overlapping Write-Read Test!" << std::endl;
                }
            } else {
                std::cout << "Cycle " << cycle << ": Cache miss." << std::endl;
            }
        }

        // Pipeline Stall Test
        if (cycle == 83) {
            if (cache->cache_hit) {
                std::cout << "Cycle " << cycle << ": Cache hit. Data: " << std::hex << cache->data_out << std::endl;
                if (cache->data_out != 0x6666) {
                    std::cout << "ERROR: Incorrect data for Pipeline Stall Test!" << std::endl;
                }
            } else {
                std::cout << "Cycle " << cycle << ": Cache miss." << std::endl;
            }
        }
        
        // Read from Evicted Address
        if (cycle == 89) {
            if (!cache->cache_hit) {
                std::cout << "Cycle " << cycle << ": Correct cache miss for evicted address." << std::endl;
            } else {
                std::cout << "ERROR: Unexpected cache hit for evicted address!" << std::endl;
            }
        }

        if (Verilated::gotFinish()) break;
    }

    tfp->close();
    delete cache;
    exit(0);
}

