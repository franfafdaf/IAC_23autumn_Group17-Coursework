#include "verilated.h"
#include "verilated_vcd_c.h"
#include "Vcache.h" // Make sure this includes the correct class name generated by Verilator

#include <iostream>

#define MAX_SIM_CYC 100

int main(int argc, char **argv) {
    Verilated::commandArgs(argc, argv);
    Vcache* cache = new Vcache;

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    cache->trace(tfp, 99);
    tfp->open("cache.vcd");

    cache->clk = 0;
    cache->we = 0;
    cache->address_in = 0;
    cache->data_in = 0;

    for (int cycle = 0; cycle < MAX_SIM_CYC; cycle++) {
        // Tick the clock for the testbench
        cache->clk = !cache->clk;
        cache->eval();
        tfp->dump(2 * cycle);
        
        // Tock the clock for the testbench
        cache->clk = !cache->clk;
        cache->eval();
        tfp->dump(2 * cycle + 1);

        // Write then read same address (expect cache hit)
        if (cycle == 10) {
            cache->we = 1; 
            cache->address_in = 0x1000;
            cache->data_in = 0xABCD;
        }

        if (cycle == 20) {
            // Attempt to read from the same address to check for a hit
            cache->address_in = 0x1000;  
        }

        if (cycle == 25) {
            cache->we = 1;  
            cache->address_in = 0x1008;  // write to a new address
            cache->data_in = 0xBEEF;
        }

        // Write different address, then read first address
        if (cycle == 30) {
            cache->we = 1;  
            cache->address_in = 0x1005;  
            cache->data_in = 0x1234;
        }
        
        //check if the first address is still correct
        if (cycle == 40) {
            cache->address_in = 0x1000;  
        }

            // check the cache replacement
        if (cycle == 45) {
            cache->we = 1;  
            cache->address_in = 0x1010;  // another new address
            cache->data_in = 0xDEAD;
        }

        if (cycle == 48) {
            cache->we = 0;  
            cache->address_in = 0x1010;  // check if the data is correct
        }
      

        // Repeated writes to the same address
        if (cycle >= 50 && cycle < 55) {
            cache->we = 1;  // Enable write
            cache->address_in = 0x1000;
            cache->data_in = cycle;  // Writing different data each cycle
        }

        if (cycle == 55) {
            cache->we = 0;  // Disable write after repeated writes
        }

        // Read from an unwritten address (expect cache miss)
        if (cycle == 60) {
            cache->we = 0;
            cache->address_in = 0x1020;  // Unwritten address
        }
  
    
        // Checks and print statements
        if (cycle == 21|| cycle == 41 || cycle == 56|| cycle == 61) {
            if (cache->hit) {
                std::cout << "Cycle " << cycle << ": Cache hit. Data: " << std::hex << cache->data_out << std::endl;
                if ((cycle == 21 && cache->data_out != 0xABCD) ||
                    (cycle == 41 && cache->data_out != 0x1234) ||
                    (cycle == 56 && cache->data_out != 54)) {  
                    std::cout << "ERROR: Incorrect data!" << std::endl;
                }
            } else {
                std::cout << "Cycle " << cycle << ": Correct Cache miss for unwritten address." << std::endl;
            }
        }

        if (cycle == 26 || cycle == 49) {
            if (cache->hit) {
                std::cout << "Cycle " << cycle << ": Cache hit. Data: " << std::hex << cache->data_out << std::endl;
                if ((cycle == 26 && cache->data_out != 0xBEEF) ||
                    (cycle == 49 && cache->data_out != 0xDEAD)) {
                    std::cout << "ERROR: Incorrect data!" << std::endl;
                }
            } else {
                std::cout << "Cycle " << cycle << ": Cache miss." << std::endl;
            }
        }

        if (Verilated::gotFinish()) break;
    }

    tfp->close();
    delete cache;
    exit(0);
}

